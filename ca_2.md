# 3. 컴퓨터 산술과 논리 연산
## 3.1 ALU의 구성요소
**CPU : ALU, CU, R-S**
```
산술 연산장치 : 산술 연산들(사칙연산)을 수행
논리 연산장치 : 논리 연산들(AND, OR, XOR, NOT등)을 수행
시프트 레지스터 : 비트들을 좌측 혹은 우측으로 이동시키는 기능을 가진 레지스터
보수기 : 2진 데이터를 2의 보수로 변환(음수<->양수 : 보수화)
상태 레지스터 : 연산 결과의 상태를 나타내는 플래그
```

## 3.2 정수의 표현
```
2진수 체계 : 0, 1, 부호 및 소수점으로 수를 표현 ex) -13.625 = -1101.101
부호 없는 정수 표현(양수만 나타냄)
```
**소수와 음수의 표현**
*소수 표현*
```
2^n, n자리로 소수를 표현
```
*음수 표현*
```
부호화-크기 표현 : 크기앞에 0(양수), 1(음수) 부호로 표현, 실제로 사용x
1의 보수 표현 : 모든 비트를 반전 0->1, 1->0
2의 보수 표현 : 1의 보수 + 1
8bit음양수 표현 1의 보수: -(2^7-1) ~ + (2^7 - 1), 2의보수 : 2^7 ~ + (2^7 -1), 양수만 0~255

비트확장 : 확장된 만큼 부호비트 복사
```

## 3.3 논리 연산
**CPU의 기능**
```
```

## 3.4 시프트 연산
**기본적인 논리 연산들**
```
NOT, AND, OR, XOR
N-bit논리 연산은 각 비트별로 연산모듈을 병렬연결하여 각각출력
```

```
AND 연산 / OR 연산 : 이미지를 잘라내거나 붙여 넣을 때 많이 쓰임
XOR 연산 / NOT 연산 : 데이터를 반전시킬 때 쓰임
```

**선택적-세트(1로만드는) 연산 / 선택적 보수 연산**
```
선택적-세트 연산 : 10010010 OR 00001111 : 앞 4비트는 그대로 뒤 4개는 1
선택적-보수 연산 : 10010010 XOR 00001111 : 앞 4비트는 그대로 뒤 4비트만 반전
-이러한 특징으로 이미지를 부분적 수정가능

마스크 연산 : 11010101 AND 00001111 : 앞 4비트는 0 뒤 4비트는 그대로 (선택적 제거)
삽입 연산 : 10010101 AND로 앞 4비트 지움, OR로 지운부분 원하는 값 삽입

비교 연산 : 결과가 모두 0이면 같은값(Z flag register값이 1로 세트)
```

```
시프트 연산 : c언어 <<, >>(논리, 산술)
논리적 시프트 : 왼쪽 혹은 오른쪽으로 비트를 한 칸씩 이동(빈자리는 0으로 채워짐)
시프트 레지스터(D flip-flop으로 만듬) : AND, AND, OR, D-flip-flop X4로 구성

순환 시프트 : 끝값이 첫값으로 들어감(역순가능), 
직렬 데이터 전송할 때 사용(내부(순환)->외부(시프트), CLK = 비트길이만큼, 시계열로 바꿔줘야 하기 때문에), 병렬(내부)
```

```
산술적 시프트 : 계산 <<, >>, 부호는 그대로, 수의 크기를 나타내는 비트만 시프트
1 1 1 0 (-2) : 초기 상태 (2의 보수)
1 1 0 0 (-4) : 산술적 좌측-시프트 결과
1 1 1 0 (-2) : 산술적 우측-시프트 결과
1 1 1 1 (-1) : 산술적 우측-시프트 결과
-위의 논리로 *2, %2연산 간단한 코딩가능
```

```
C(캐리) 플래그 : 계산했을 때 계산결과가 들어가는 플래그(큰값 연산)
```

## 3.5 정수의 산술 연산
**실제 모두 2의 보수를 이용한 연산**
```
A <- A' + 1 : 보수화(2의 보수 변환)
사칙연산, 1증가, 1감소
```
### 3.5.1 덧셈
*2의 보수를 이용한 덧셈*
```
-2^(n-1) ~ +(2(n-1)-1)
full-adder를 비트수만큼 병렬 연결하여 병렬 가산기 구성 
4비트 병렬가산기: V = C3 XOR C4(오버플로우), 
```

### 3.5.2 뺄셈 (덧셈으로 구현)
*A-B = A+(-B)*
```
덧셈회로에서 B->(보수기(ALU) 통과)->(-B)로 계산
뺄셈 오버플로우 = C3 XOR C4, 0110+0100=1010=-6, 6-(-4) = 10
```

## 3.6 부동소수점 수의 표현
**부동소수점 표현(floating-point)**
*소수점의 위치를 이동시킬 수 있는 수 표현 방법->수 표현 범위 확대*
```
N = (-1)^S M X B^E
S: 부호, M:가수, B:기수, E:지순
정규화된 표현(모든 수를 한 가지로 통일)
+- 0.1bbb..b X 2^E

ex) 0.1101 X 2^5 = S 0 E 00000101 M 11010000000000000000
```

**2의 보수를 쓰지 않고 지수를 바이어스된 수로 표현**
```
-13.625
13.625 = 1101.101 = 0.1101101 X 2^4
지수(E) = 00000100 + 10000000 = 10000100 (바이어스 128을 더한다)
S 1 E 10000100 M (0.1)101101000000000000 실제로 (24자리)
음/양수 언더/오버플로우 (0/무한대)
```

**IEEE 754 표준 부동소수점**
```
N = (-1)^S 2^(E-127) (1.M)     0.1 대신 1.으로씀
지수 필드 : 바이어스 127 사용

64비트일때 E = 11이므로 바이어스 1023사용
```

```
지수 E = -00000010 + 01111111 = 01111101
E = 255고 M != 0 이면 NaN / M = 0이면 오버플로우
E = 0이고 M != 0 이면 1에 가까운 숫자 / M = 0이면 언더플로우
```

## 3.7 부동소수점 산술 연산
**덧셈 뺄셈**
```
지수가 큰값에 맞춰 지수를 조정하고 정규화(1.M)
파이프라인 만큼 속도 향상(배열들의 덧셈에서 유용)
```

**곱셈 나눗셈**
```
곱셈 : 가수는 곱하고 지수는 더하고
나눗셈 : 가수는 나누고 지수는 뺀다.
```

**오버/언더플로우**
```
지수는 어쩔 수 없음
가수 언더플로우 : 00000000001 반올림
가수 오버플로우 : 소수점 위치를 변경해서 정규화
```
